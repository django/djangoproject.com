"""
Some models for pulling data from Trac.

Initially generated by inspectdb then modified heavily by hand, often by
consulting http://trac.edgewall.org/wiki/TracDev/DatabaseSchema.

A few notes on tables that're left out and why:

    * All the session and permission tables: they're just not needed.
    * Enum: I don't know what this is or what it's for.
    * NodeChange: Ditto.

These models are far from perfect but are Good Enough(tm) to get some useful data out.

One important mismatch between these models and the Trac database has to do with
composite primary keys. Trac uses them for several tables, but Django does not support
them yet (ticket #373).

These are the tables that use them:

    * ticket_custom (model TicketCustom)
    * ticket_change (model TicketChange)
    * wiki (model Wiki)
    * attachment (model Attachment)

To make these work with Django (for some definition of the word "work") we mark only
one of their field as being the primary key (primary_key=True).
This is obviously incorrect but — somewhat suprisingly — it doesn't break **everything**
and the little that does actually work is good enough for what we're trying to do:

    * Model.objects.create(...) correctly creates the object in the db
    * Most queryset/manager methods work (in particular filter(), exclude(), all()
      and count())

On the other hand, here's what absolutely DOES NOT work (the list is sadly not
exhaustive):

    * Updating a model instance with save() will update ALL ROWS that happen to share
      the value for the field used as the "fake" primary key if they exist (resulting
      in a DBError)
    * The admin won't work (the "pk" field shortcut can't be used reliably since it can
      return multiple rows)

"""

from datetime import date
from functools import reduce
from operator import and_, or_
from urllib.parse import parse_qs

from django.db import models

from .tractime import dayrange, time_property


class JSONBObjectAgg(models.Aggregate):
    function = "JSONB_OBJECT_AGG"  # PostgreSQL only.
    output_field = models.JSONField()


class TicketQuerySet(models.QuerySet):
    def with_custom(self):
        """
        Annotate the "custom" properties as a json blob.
        """
        return self.annotate(
            custom=JSONBObjectAgg("custom_fields__name", "custom_fields__value")
        )

    def from_querystring(self, querystring):
        parsed = parse_qs(querystring)
        model_fields = {f.name for f in self.model._meta.get_fields()}
        custom_lookup_required = False
        filter_kwargs, exclude_kwargs = {}, {}

        for field, (value,) in parsed.items():
            if field == "time":
                if value == "today..":
                    timestamp_range = dayrange(date.today(), 1)
                elif value == "thisweek..":
                    timestamp_range = dayrange(date.today(), 7)
                else:
                    raise ValueError(f"Unsupported time value {value}")

                filter_kwargs["_time__range"] = timestamp_range
                continue
            elif field not in model_fields:
                custom_lookup_required = True
                field = f"custom__{field}"
            if value.startswith("!"):
                exclude_kwargs[field] = value[1:]
            else:
                filter_kwargs[field] = value

        queryset = self
        if custom_lookup_required:
            queryset = queryset.with_custom()

        if exclude_kwargs:
            # negative values needed to be OR-ed for exclude
            q = reduce(or_, [models.Q(**{k: v}) for k, v in exclude_kwargs.items()])
            queryset = queryset.exclude(q)
        if filter_kwargs:
            # whereas positive values are AND-ed
            q = reduce(and_, [models.Q(**{k: v}) for k, v in filter_kwargs.items()])
            queryset = queryset.filter(q)

        return queryset


class Ticket(models.Model):
    id = models.AutoField(primary_key=True)
    type = models.TextField()

    _time = models.BigIntegerField(db_column="time", null=True)
    time = time_property("_time")

    _changetime = models.BigIntegerField(db_column="changetime", null=True)
    changetime = time_property("_changetime")

    component = models.ForeignKey(
        "Component",
        related_name="tickets",
        db_column="component",
        on_delete=models.DO_NOTHING,
        null=True,
    )
    severity = models.TextField()
    owner = models.TextField()
    reporter = models.TextField()
    cc = models.TextField()
    version = models.ForeignKey(
        "Version",
        related_name="tickets",
        db_column="version",
        on_delete=models.DO_NOTHING,
        null=True,
    )
    milestone = models.ForeignKey(
        "Milestone",
        related_name="tickets",
        db_column="milestone",
        on_delete=models.DO_NOTHING,
        null=True,
    )
    priority = models.TextField()
    status = models.TextField()
    resolution = models.TextField()
    summary = models.TextField()
    description = models.TextField()
    keywords = models.TextField()

    objects = TicketQuerySet.as_manager()

    class Meta:
        db_table = "ticket"
        managed = False

    def __str__(self):
        return f"#{self.id}: {self.summary}"


class TicketCustom(models.Model):
    ticket = models.ForeignKey(
        Ticket,
        related_name="custom_fields",
        db_column="ticket",
        primary_key=True,  # XXX See note at the top about composite pk
        on_delete=models.DO_NOTHING,
    )
    name = models.TextField()
    value = models.TextField()

    class Meta:
        db_table = "ticket_custom"
        managed = False

    def __str__(self):
        return f"{self.name}: {self.value}"


class TicketChange(models.Model):
    ticket = models.ForeignKey(
        Ticket,
        related_name="changes",
        db_column="ticket",
        primary_key=True,  # XXX See note at the top about composite pk
        on_delete=models.DO_NOTHING,
    )
    author = models.TextField()
    field = models.TextField()
    oldvalue = models.TextField()
    newvalue = models.TextField()

    _time = models.BigIntegerField(db_column="time")
    time = time_property("_time")

    class Meta:
        db_table = "ticket_change"
        managed = False
        ordering = ["_time"]

    def __str__(self):
        return f"#{self.ticket.id}: changed {self.field}"


class Component(models.Model):
    name = models.TextField(primary_key=True)
    owner = models.TextField()
    description = models.TextField()

    class Meta:
        db_table = "component"
        managed = False

    def __str__(self):
        return self.name


class Version(models.Model):
    name = models.TextField(primary_key=True)
    description = models.TextField()

    _time = models.BigIntegerField(db_column="time")
    time = time_property("_time")

    class Meta:
        db_table = "version"
        managed = False

    def __str__(self):
        return self.name


class Milestone(models.Model):
    name = models.TextField(primary_key=True)
    description = models.TextField()

    _due = models.BigIntegerField(db_column="_due")
    due = time_property("_due")

    _completed = models.BigIntegerField(db_column="_completed")
    completed = time_property("_completed")

    class Meta:
        db_table = "milestone"
        managed = False

    def __str__(self):
        return self.name


class SingleRepoRevisionManager(models.Manager):
    """
    Forces Revision to only query against a single repo, thus making
    Revision.rev behave something like a primary key.
    """

    def __init__(self, repo_id):
        self.repo_id = repo_id
        super().__init__()

    def get_queryset(self):
        qs = super().get_queryset()
        return qs.filter(repos=self.repo_id)


# Django's Trac uses a single repository with id 1 in the database
# These models will not work if another repository is ever added
# (but that seems unlikely at this point)
SINGLE_REPO_ID = 1


class Revision(models.Model):
    repos = models.IntegerField(default=SINGLE_REPO_ID)
    rev = models.TextField(primary_key=True)

    _time = models.BigIntegerField(db_column="time")
    time = time_property("_time")

    author = models.TextField()
    message = models.TextField()

    objects = SingleRepoRevisionManager(repo_id=SINGLE_REPO_ID)

    class Meta:
        db_table = "revision"
        managed = False

    def __str__(self):
        return "[{}] {}".format(self.rev, self.message.split("\n", 1)[0])


class Wiki(models.Model):
    name = models.TextField(
        primary_key=True
    )  # XXX See note at the top about composite pk
    version = models.IntegerField()
    _time = models.BigIntegerField(db_column="time")
    time = time_property("_time")
    author = models.TextField()
    text = models.TextField()
    comment = models.TextField()
    readonly = models.IntegerField()

    class Meta:
        db_table = "wiki"
        managed = False

    def __str__(self):
        return f"{self.name} (v{self.version})"


class Attachment(models.Model):
    type = models.TextField()
    id = models.TextField(
        primary_key=True
    )  # XXX See note at the top about composite pk
    filename = models.TextField()
    size = models.IntegerField()
    _time = models.BigIntegerField(db_column="time")
    time = time_property("_time")
    description = models.TextField()
    author = models.TextField()

    class Meta:
        db_table = "attachment"
        managed = False

    def __str__(self):
        attached_to = ("#%s" % self.id) if self.type == "ticket" else self.id
        return f"{self.filename} (on {attached_to})"
