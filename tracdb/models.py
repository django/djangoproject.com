"""
Some models for pulling data from Trac.

Initially generated by inspectdb then modified heavily by hand, often by
consulting http://trac.edgewall.org/wiki/TracDev/DatabaseSchema.

A few notes on tables that're left out and why:

    * All the session and permission tables: they're just not needed.
    * Enum: I don't know what this is or what it's for.
    * NodeChange: Ditto.

These models are far from perfect but are Good Enough(tm) to get some useful data out.

One important mismatch between these models and the Trac database has to do with
composite primary keys. Trac uses them for several tables, but Django does not support
them yet (ticket #373).

These are the tables that use them:

    * ticket_custom (model TicketCustom)
    * ticket_change (model TicketChange)
    * wiki (model Wiki)
    * attachment (model Attachment)

To make these work with Django (for some definition of the word "work") we mark only
one of their field as being the primary key (primary_key=True).
This is obviously incorrect but — somewhat suprisingly — it doesn't break **everything**
and the little that does actually work is good enough for what we're trying to do:

    * Model.objects.create(...) correctly creates the object in the db
    * Most queryset/manager methods work (in particular filter(), exclude(), all()
      and count())

On the other hand, here's what absolutely DOES NOT work (the list is sadly not
exhaustive):

    * Updating a model instance with save() will update ALL ROWS that happen to share
      the value for the field used as the "fake" primary key if they exist (resulting
      in a DBError)
    * The admin won't work (the "pk" field shortcut can't be used reliably since it can
      return multiple rows)

"""

import datetime
from functools import reduce
from operator import and_, or_
from urllib.parse import parse_qs

from django.db import models

_epoc = datetime.datetime(1970, 1, 1, tzinfo=datetime.timezone.utc)


class time_property:
    """
    Convert Trac timestamps into UTC datetimes.

    See http://trac.edgewall.org/browser//branches/0.12-stable/trac/util/datefmt.py
    for Trac's version of all this. Mine's something of a simplification.

    Like the rest of this module this is far from perfect -- no setters, for
    example! That's good enough for now.
    """

    def __init__(self, fieldname):
        self.fieldname = fieldname

    def __get__(self, instance, owner):
        if instance is None:
            return self
        timestamp = getattr(instance, self.fieldname)
        if timestamp is None:
            return None
        return _epoc + datetime.timedelta(microseconds=timestamp)


class JSONBObjectAgg(models.Aggregate):
    function = "JSONB_OBJECT_AGG"  # PostgreSQL only.
    output_field = models.JSONField()


class TicketQuerySet(models.QuerySet):
    def with_custom(self):
        """
        Annotate the "custom" properties as a json blob.
        """
        return self.annotate(
            custom=JSONBObjectAgg("custom_fields__name", "custom_fields__value")
        )

    def from_querystring(self, querystring):
        parsed = parse_qs(querystring)
        model_fields = {f.name for f in self.model._meta.get_fields()}
        custom_lookup_required = False
        filter_kwargs, exclude_kwargs = {}, {}

        for field, (value,) in parsed.items():
            if field not in model_fields:
                custom_lookup_required = True
                field = f"custom__{field}"
            if value.startswith("!"):
                exclude_kwargs[field] = value[1:]
            else:
                filter_kwargs[field] = value

        queryset = self
        if custom_lookup_required:
            queryset = queryset.with_custom()

        if exclude_kwargs:
            # negative values needed to be OR-ed for exclude
            q = reduce(or_, [models.Q(**{k: v}) for k, v in exclude_kwargs.items()])
            queryset = queryset.exclude(q)
        if filter_kwargs:
            # whereas positive values are AND-ed
            q = reduce(and_, [models.Q(**{k: v}) for k, v in filter_kwargs.items()])
            queryset = queryset.filter(q)

        return queryset


class Ticket(models.Model):
    id = models.AutoField(primary_key=True)
    type = models.TextField()

    _time = models.BigIntegerField(db_column="time", null=True)
    time = time_property("_time")

    _changetime = models.BigIntegerField(db_column="changetime", null=True)
    changetime = time_property("_changetime")

    component = models.ForeignKey(
        "Component",
        related_name="tickets",
        db_column="component",
        on_delete=models.DO_NOTHING,
        null=True,
    )
    severity = models.TextField()
    owner = models.TextField()
    reporter = models.TextField()
    cc = models.TextField()
    version = models.ForeignKey(
        "Version",
        related_name="tickets",
        db_column="version",
        on_delete=models.DO_NOTHING,
        null=True,
    )
    milestone = models.ForeignKey(
        "Milestone",
        related_name="tickets",
        db_column="milestone",
        on_delete=models.DO_NOTHING,
        null=True,
    )
    priority = models.TextField()
    status = models.TextField()
    resolution = models.TextField()
    summary = models.TextField()
    description = models.TextField()
    keywords = models.TextField()

    objects = TicketQuerySet.as_manager()

    class Meta:
        db_table = "ticket"
        managed = False

    def __str__(self):
        return f"#{self.id}: {self.summary}"


class TicketCustom(models.Model):
    ticket = models.ForeignKey(
        Ticket,
        related_name="custom_fields",
        db_column="ticket",
        primary_key=True,  # XXX See note at the top about composite pk
        on_delete=models.DO_NOTHING,
    )
    name = models.TextField()
    value = models.TextField()

    class Meta:
        db_table = "ticket_custom"
        managed = False

    def __str__(self):
        return f"{self.name}: {self.value}"


class TicketChange(models.Model):
    ticket = models.ForeignKey(
        Ticket,
        related_name="changes",
        db_column="ticket",
        primary_key=True,  # XXX See note at the top about composite pk
        on_delete=models.DO_NOTHING,
    )
    author = models.TextField()
    field = models.TextField()
    oldvalue = models.TextField()
    newvalue = models.TextField()

    _time = models.BigIntegerField(db_column="time")
    time = time_property("_time")

    class Meta:
        db_table = "ticket_change"
        managed = False
        ordering = ["_time"]

    def __str__(self):
        return f"#{self.ticket.id}: changed {self.field}"


class Component(models.Model):
    name = models.TextField(primary_key=True)
    owner = models.TextField()
    description = models.TextField()

    class Meta:
        db_table = "component"
        managed = False

    def __str__(self):
        return self.name


class Version(models.Model):
    name = models.TextField(primary_key=True)
    description = models.TextField()

    _time = models.BigIntegerField(db_column="time")
    time = time_property("_time")

    class Meta:
        db_table = "version"
        managed = False

    def __str__(self):
        return self.name


class Milestone(models.Model):
    name = models.TextField(primary_key=True)
    description = models.TextField()

    _due = models.BigIntegerField(db_column="_due")
    due = time_property("due")

    _completed = models.BigIntegerField(db_column="_completed")
    completed = time_property("completed")

    class Meta:
        db_table = "milestone"
        managed = False

    def __str__(self):
        return self.name


class SingleRepoRevisionManager(models.Manager):
    """
    Forces Revision to only query against a single repo, thus making
    Revision.rev behave something like a primary key.
    """

    def __init__(self, repo_id):
        self.repo_id = repo_id
        super().__init__()

    def get_queryset(self):
        qs = super().get_queryset()
        return qs.filter(repos=self.repo_id)


# Django's Trac uses a single repository with id 1 in the database
# These models will not work if another repository is ever added
# (but that seems unlikely at this point)
SINGLE_REPO_ID = 1


class Revision(models.Model):
    repos = models.IntegerField(default=SINGLE_REPO_ID)
    rev = models.TextField(primary_key=True)

    _time = models.BigIntegerField(db_column="time")
    time = time_property("time")

    author = models.TextField()
    message = models.TextField()

    objects = SingleRepoRevisionManager(repo_id=SINGLE_REPO_ID)

    class Meta:
        db_table = "revision"
        managed = False

    def __str__(self):
        return "[{}] {}".format(self.rev, self.message.split("\n", 1)[0])


class Wiki(models.Model):
    name = models.TextField(
        primary_key=True
    )  # XXX See note at the top about composite pk
    version = models.IntegerField()
    _time = models.BigIntegerField(db_column="time")
    time = time_property("time")
    author = models.TextField()
    text = models.TextField()
    comment = models.TextField()
    readonly = models.IntegerField()

    class Meta:
        db_table = "wiki"
        managed = False

    def __str__(self):
        return f"{self.name} (v{self.version})"


class Attachment(models.Model):
    type = models.TextField()
    id = models.TextField(
        primary_key=True
    )  # XXX See note at the top about composite pk
    filename = models.TextField()
    size = models.IntegerField()
    _time = models.BigIntegerField(db_column="time")
    time = time_property("time")
    description = models.TextField()
    author = models.TextField()

    class Meta:
        db_table = "attachment"
        managed = False

    def __str__(self):
        attached_to = ("#%s" % self.id) if self.type == "ticket" else self.id
        return f"{self.filename} (on {attached_to})"
